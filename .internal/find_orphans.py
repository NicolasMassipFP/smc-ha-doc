#!/usr/bin/env python3
"""
Script to find orphaned markdown files that are not referenced by any other markdown file.
- Finds all markdown files in the project
- Extracts all markdown links from each file
- Properly decodes URL-encoded characters
- Uses relative path resolution from each markdown file's location
- Identifies orphaned files (not referenced by any other markdown file)
- Creates ORPHAN.md file with the list of orphaned files

To be run in root folder: python3 .internal/find_orphans.py
Generated by Claude Sonnet 4.5
"""

import os
import re
import urllib.parse
from pathlib import Path
from typing import Dict, List, Set


def find_all_markdown_files(root_dir: str) -> List[Path]:
    """Find all markdown files in the project."""
    root = Path(root_dir)
    return list(root.rglob("*.md"))


def decode_url_path(path: str) -> str:
    """Decode URL-encoded characters in a path."""
    return urllib.parse.unquote(path)


def extract_markdown_links(content: str) -> List[str]:
    """
    Extract all markdown file links from markdown content.
    Returns list of URLs pointing to .md files.
    """
    # Match markdown links: [text](url)
    pattern = r"\[([^\]]*)\]\(([^)]+)\)"
    links = []

    for match in re.finditer(pattern, content):
        url = match.group(2)
        # Remove any anchor/fragment from URL
        url_without_anchor = url.split("#")[0]

        # Only include .md files, skip external URLs
        if url_without_anchor.endswith(".md") and not url.startswith(
            ("http://", "https://", "ftp://")
        ):
            links.append(url_without_anchor)

    return links


def resolve_link_path(md_file_path: Path, link: str, root_dir: Path) -> Path:
    """
    Resolve a relative link from a markdown file to an absolute path.
    Handles URL decoding and relative path resolution.
    Returns the resolved path relative to root_dir.
    """
    # Decode URL encoding
    decoded_link = decode_url_path(link)

    # Remove anchor/fragment
    decoded_link = decoded_link.split("#")[0]

    # Get the directory containing the markdown file
    md_dir = md_file_path.parent

    # Resolve the link relative to the markdown file's directory
    target_path = (md_dir / decoded_link).resolve()

    return target_path


def find_referenced_files(md_files: List[Path], root_dir: Path) -> Set[Path]:
    """
    Find all markdown files that are referenced by other markdown files.
    Returns a set of absolute paths to referenced files.
    """
    referenced = set()

    for md_file in md_files:
        try:
            with open(md_file, "r", encoding="utf-8") as f:
                content = f.read()

            # Extract all markdown links
            md_links = extract_markdown_links(content)

            # Resolve each link to an absolute path
            for link in md_links:
                target_path = resolve_link_path(md_file, link, root_dir)

                # Check if the resolved path exists and is a file
                if target_path.exists() and target_path.is_file():
                    referenced.add(target_path)

        except Exception as e:
            print(f"Warning: Error processing {md_file}: {e}")

    return referenced


def create_orphan_report(orphaned_files: List[Path], root_dir: Path, output_file: Path):
    """
    Create ORPHAN.md file with the list of orphaned markdown files.
    """
    with open(output_file, "w", encoding="utf-8") as f:
        f.write("# Orphaned Markdown Files\n\n")
        f.write(
            "This file lists all markdown files in the project that are not referenced by any other markdown file.\n\n"
        )
        f.write(f"**Total orphaned files:** {len(orphaned_files)}\n\n")
        f.write("---\n\n")

        if orphaned_files:
            f.write("## Orphaned Files\n\n")

            # Sort files for better readability
            sorted_files = sorted(
                orphaned_files, key=lambda p: str(p.relative_to(root_dir))
            )

            for orphan in sorted_files:
                rel_path = orphan.relative_to(root_dir)
                f.write(f"- `{rel_path}`\n")
        else:
            f.write(
                "**No orphaned files found!** All markdown files are referenced by at least one other markdown file.\n"
            )


def main():
    """Main function to find orphaned markdown files."""
    # Get the script's directory (should be the project root)
    root_dir = Path(__file__).parent

    print(f"Scanning for markdown files in: {root_dir}")

    # Find all markdown files
    md_files = find_all_markdown_files(root_dir)
    print(f"Found {len(md_files)} markdown files")

    # Convert to absolute paths
    md_files_abs = [f.resolve() for f in md_files]

    # Find all referenced markdown files
    print("Analyzing references...")
    referenced = find_referenced_files(md_files_abs, root_dir)
    print(f"Found {len(referenced)} referenced markdown files")

    # Find orphaned files (files that are not referenced by any other file)
    all_files_set = set(md_files_abs)
    orphaned = all_files_set - referenced

    # Remove ORPHAN.md from the orphaned list if it exists
    orphan_report_path = (root_dir / "ORPHAN.md").resolve()
    orphaned.discard(orphan_report_path)

    orphaned_list = list(orphaned)

    print(f"\nFound {len(orphaned_list)} orphaned files")

    # Create ORPHAN.md report
    create_orphan_report(orphaned_list, root_dir, orphan_report_path)
    print(f"\nOrphan report created: ORPHAN.md")

    # Display orphaned files
    if orphaned_list:
        print("\nOrphaned files:")
        for orphan in sorted(orphaned_list, key=lambda p: str(p.relative_to(root_dir))):
            rel_path = orphan.relative_to(root_dir)
            print(f"  - {rel_path}")


if __name__ == "__main__":
    main()
