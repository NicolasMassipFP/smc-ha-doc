#!/usr/bin/env python3
"""
Script to validate markdown and PNG links in all markdown files.
- Finds all links to .md and .png files
- Validates that target files exist
- Injects #ERRORLINK for invalid .md links
- Injects #ERRORPNG for invalid .png links
- Properly decodes URL-encoded characters
- Performs case-sensitive file matching
- Uses relative path resolution from each markdown file's location

To be run in root folder: python3 .internal/validate_links.py
Generated by Claude Sonet 4.5
"""

import os
import re
import urllib.parse
from pathlib import Path
from typing import List, Set, Tuple


def find_all_markdown_files(root_dir: str) -> List[Path]:
    """Find all markdown files in the project."""
    root = Path(root_dir)
    return list(root.rglob("*.md"))


def decode_url_path(path: str) -> str:
    """Decode URL-encoded characters in a path."""
    return urllib.parse.unquote(path)


def extract_links(content: str, file_type: str) -> List[Tuple[str, int, int]]:
    """
    Extract links to specific file types from markdown content.
    Returns list of (link_text, start_pos, end_pos) tuples.
    """
    # Match markdown links: [text](url)
    # Capture the URL and the position of the closing parenthesis
    pattern = r"\[([^\]]*)\]\(([^)]+)\)"
    links = []

    for match in re.finditer(pattern, content):
        url = match.group(2)
        # Remove any anchor/fragment from URL
        url_without_anchor = url.split("#")[0]

        if url_without_anchor.endswith(file_type):
            links.append((url, match.start(2), match.end()))

    return links


def resolve_link_path(md_file_path: Path, link: str) -> Path:
    """
    Resolve a relative link from a markdown file to an absolute path.
    Handles URL decoding and relative path resolution.
    """
    # Decode URL encoding
    decoded_link = decode_url_path(link)

    # Remove anchor/fragment
    decoded_link = decoded_link.split("#")[0]

    # Get the directory containing the markdown file
    md_dir = md_file_path.parent

    # Resolve the link relative to the markdown file's directory
    target_path = (md_dir / decoded_link).resolve()

    return target_path


def file_exists_case_sensitive(path: Path) -> bool:
    """
    Check if file exists with case-sensitive matching.
    """
    if not path.exists():
        return False

    # Verify case-sensitive match
    # Get the actual path components from the filesystem
    try:
        # Navigate up the path and verify each component matches exactly
        current = path
        parts_to_check = []

        # Collect parts that need checking (up to existing parent)
        while current != current.parent:
            parts_to_check.insert(0, current.name)
            current = current.parent
            if not current.exists():
                break

        # Now verify each part matches case-sensitively
        check_path = current
        for part in parts_to_check:
            if not check_path.exists():
                return False

            # List directory contents
            if check_path.is_dir():
                children = [p.name for p in check_path.iterdir()]
                if part not in children:
                    return False

            check_path = check_path / part

        return check_path.exists() and check_path == path
    except (OSError, PermissionError):
        return False


def validate_and_mark_links(md_file: Path, root_dir: Path) -> Tuple[str, int, int]:
    """
    Validate links in a markdown file and mark invalid ones.
    Returns (modified_content, num_invalid_md, num_invalid_png).
    """
    with open(md_file, "r", encoding="utf-8") as f:
        content = f.read()

    original_content = content
    invalid_md_count = 0
    invalid_png_count = 0

    # Process .md links
    md_links = extract_links(content, ".md")
    # Sort by position in reverse order to preserve positions during modification
    md_links.sort(key=lambda x: x[1], reverse=True)

    for link, start_pos, end_pos in md_links:
        # Check if already marked
        if end_pos < len(content) and content[end_pos : end_pos + 10] == "#ERRORLINK":
            continue

        target_path = resolve_link_path(md_file, link)

        if not file_exists_case_sensitive(target_path):
            # Insert #ERRORLINK after closing parenthesis
            content = content[:end_pos] + "#ERRORLINK" + content[end_pos:]
            invalid_md_count += 1

    # Process .png links
    png_links = extract_links(content, ".png")
    # Sort by position in reverse order
    png_links.sort(key=lambda x: x[1], reverse=True)

    for link, start_pos, end_pos in png_links:
        # Check if already marked
        if end_pos < len(content) and content[end_pos : end_pos + 9] == "#ERRORPNG":
            continue

        target_path = resolve_link_path(md_file, link)

        if not file_exists_case_sensitive(target_path):
            # Insert #ERRORPNG after closing parenthesis
            content = content[:end_pos] + "#ERRORPNG" + content[end_pos:]
            invalid_png_count += 1

    return content, invalid_md_count, invalid_png_count


def main():
    """Main function to process all markdown files."""
    # Get the script's directory (should be the project root)
    root_dir = Path(__file__).parent.parent

    print(f"Scanning for markdown files in: {root_dir}")

    # Find all markdown files
    md_files = find_all_markdown_files(root_dir)
    print(f"Found {len(md_files)} markdown files")

    total_invalid_md = 0
    total_invalid_png = 0
    modified_files = []

    # Process each markdown file
    for md_file in md_files:
        rel_path = md_file.relative_to(root_dir)

        try:
            new_content, invalid_md, invalid_png = validate_and_mark_links(
                md_file, root_dir
            )

            if invalid_md > 0 or invalid_png > 0:
                # Write the modified content back
                with open(md_file, "w", encoding="utf-8") as f:
                    f.write(new_content)

                modified_files.append(str(rel_path))
                print(f"✗ {rel_path}")
                if invalid_md > 0:
                    print(f"  - Invalid .md links: {invalid_md}")
                if invalid_png > 0:
                    print(f"  - Invalid .png links: {invalid_png}")

                total_invalid_md += invalid_md
                total_invalid_png += invalid_png
            else:
                print(f"✓ {rel_path}")

        except Exception as e:
            print(f"✗ Error processing {rel_path}: {e}")

    # Summary
    print("\n" + "=" * 60)
    print("SUMMARY")
    print("=" * 60)
    print(f"Total markdown files processed: {len(md_files)}")
    print(f"Files with invalid links: {len(modified_files)}")
    print(f"Total invalid .md links marked: {total_invalid_md}")
    print(f"Total invalid .png links marked: {total_invalid_png}")

    if modified_files:
        print("\nModified files:")
        for f in modified_files:
            print(f"  - {f}")


if __name__ == "__main__":
    main()
